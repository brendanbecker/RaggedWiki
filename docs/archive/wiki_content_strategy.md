# SRE Wiki Content Strategy: Chunking Decision Matrix

## Why Strategy Selection Matters
The research paper shows that choosing the wrong chunking mode during ingestion creates unrecoverable recall loss later in the pipeline, with naive fixed-size splits causing a 9% gap between best and worst systems (`Enterprise RAG Recall Optimization Research.md:24`). It further stresses that the optimal approach is structure-aware chunking aligned to the document’s inherent layout (`Enterprise RAG Recall Optimization Research.md:50`-`Enterprise RAG Recall Optimization Research.md:56`). The Document Parser guidance codifies this into Layout-Aware Hierarchical, Code-Aware, and Dual-Storage patterns tuned for Markdown docs, code, and research respectively (`document-parser/references/chunking_principles.md:18`-`document-parser/references/chunking_principles.md:74`).

## Decision Matrix
| Content Type | Dominant Traits | Recommended Strategy | Logic & Citations |
| --- | --- | --- | --- |
| Runbooks / On-call Playbooks | Structured Markdown with prerequisites, numbered steps, validations | Layout-Aware Hierarchical | Headers already encode the hierarchy, so splitting on `#`/`##` keeps every remediation step complete while adhering to the 400–900 token target (`Enterprise RAG Recall Optimization Research.md:30`-`Enterprise RAG Recall Optimization Research.md:33`, `document-parser/references/chunking_principles.md:57`-`document-parser/references/chunking_principles.md:61`). |
| Post-Mortems / Incident Reports | Narrative prose with standard sections (Executive Summary, Timeline, RCA, Actions) | Layout-Aware Hierarchical | Each section is a logical unit needed verbatim for audits; respecting the layout prevents the 92% hallucination spikes seen when stories are split mid-section (`Enterprise RAG Recall Optimization Research.md:43`). |
| Terraform Modules & CI/CD Pipelines | Declarative blocks, nested resources, macros | Code-Aware Chunking | Code-specific chunking preserves entire resources/functions, mirroring the paper’s recommendation to chunk by logical code blocks for precision while keeping syntax intact (`Enterprise RAG Recall Optimization Research.md:55`). |
| Kubernetes YAML / Helm Charts | Repetitive manifests, key-value trees, limited prose | Code-Aware Chunking with schema-aware parsers | Treat each manifest as the atomic unit so selectors, metadata, and spec blocks travel together; use AST or YAML path splits to keep resources below 900 tokens (`document-parser/references/chunking_principles.md:69`-`document-parser/references/chunking_principles.md:73`). |
| Shell Scripts / Operational Tooling | Functions, loops, comments | Code-Aware Chunking | Splitting on function boundaries ensures retrieval never returns half a mitigation script, maintaining the precision mandate highlighted in the precision-vs-context section (`Enterprise RAG Recall Optimization Research.md:30`). |
| Raw Logs | No hierarchy, but strict chronological signal | Fixed-Size Sliding Window (512-token windows, 128-token overlap) | Without semantic markers, layout-aware rules cannot apply; overlapping windows preserve enough context to answer “what happened before this error” while honoring the trade-off between context and precision from the study (`Enterprise RAG Recall Optimization Research.md:30`-`Enterprise RAG Recall Optimization Research.md:33`). |
| Stack Traces | Sequential frames, often exceeding token target | Fixed-Size Sliding Window with call-frame aware splitter | Use windowing anchored on frame boundaries so causal chains remain intact; overlap ensures the same frame appears in two windows, mitigating the fragmentation risks described in the precision/context trade-off (`Enterprise RAG Recall Optimization Research.md:30`-`Enterprise RAG Recall Optimization Research.md:33`). |
| Monitoring Alert Catalogs | Tables + short prose per alert | Layout-Aware Hierarchical | Alerts typically follow a template (Signal, Threshold, Response). Layout-aware chunking keeps each alert self-contained so BM25 can match on alert names and Stage‑2 retrieval can fetch the detailed remediation notes (`Enterprise RAG Recall Optimization Research.md:74`-`Enterprise RAG Recall Optimization Research.md:83`). |

## Example Analyses
### 1. Runbooks/Post-Mortems (Prose) → Layout-Aware Hierarchical
- **Structure Fit:** Runbooks and RCAs already use headers for prerequisites, impact, steps, and validation, matching the Document Parser recipe of splitting on Markdown headings and maintaining parent-child links (`document-parser/references/chunking_principles.md:57`-`document-parser/references/chunking_principles.md:61`).
- **Risk Mitigated:** Prevents the “small chunk vs large chunk” fragmentation highlighted in the paper’s precision/context trade-off because every chunk remains semantically whole (`Enterprise RAG Recall Optimization Research.md:30`-`Enterprise RAG Recall Optimization Research.md:33`).
- **Operational Benefit:** Enables Parent-Child retrieval—dense search hits the small “child” (e.g., Step 2) but the system promotes the full parent section so incident responders see the entire command sequence with guardrails (`Enterprise RAG Recall Optimization Research.md:235`-`Enterprise RAG Recall Optimization Research.md:244`).

### 2. Terraform/YAML/Scripts → Code-Aware Chunking
- **Structure Fit:** Infrastructure-as-code expresses logic in blocks and functions, so splitting by AST nodes or resource boundaries mirrors the paper’s recommendation for code repositories and prevents syntax corruption (`Enterprise RAG Recall Optimization Research.md:55`, `document-parser/references/chunking_principles.md:69`-`document-parser/references/chunking_principles.md:73`).
- **Risk Mitigated:** Keeps identifiers, variables, and comments inside the same chunk, so dense retrieval can match both semantic context (“enable_public_access”) and literal tokens (resource names) without the dilution seen in >900-token blobs.
- **Operational Benefit:** Results map one-to-one with apply plans or pipeline stages, letting engineers cite the exact stanza that needs editing when shipping hotfixes.

### 3. Raw Logs/Stack Traces → Fixed-Size Sliding Window
- **Structure Fit:** Logs have ordering but lack headers; forcing Layout-Aware rules would introduce spurious boundaries, so we use 512-token sliding windows with 25% overlap anchored on timestamp changes to emulate context preservation.
- **Risk Mitigated:** The overlap directly addresses the context-loss problem described in the foundational trade-off discussion, ensuring that the before/after lines around an error stay together (`Enterprise RAG Recall Optimization Research.md:30`-`Enterprise RAG Recall Optimization Research.md:33`).
- **Operational Benefit:** Windows are deterministic, enabling quick diffing between ingest runs and easy alignment with raw storage offsets for replay.

By pairing each SRE Wiki content type with the strategy that matches its natural structure, we preserve semantic coherence during ingestion and unlock the multi-stage retrieval gains quantified in the research (hybrid search + cross-encoder stack), while minimizing hallucinations in the generated responses.
